7장의 핵심 내용 정리
7장은 프로그램에서 데이터를 효율적으로 구성하고 처리하기 위한 다양한 데이터 구조와 관련된 핵심 개념들을 다룹니다. 단순히 각 자료 구조의 특징을 나열하는 것을 넘어, 각 자료 구조가 등장하게 된 배경, 장단점, 그리고 실제 시스템에서 어떻게 활용되는지에 대한 깊이 있는 설명을 제공합니다.
기본 데이터 타입과 포인터
•
프로그래밍 언어는 다양한 기본 데이터 타입(예: 정수, 실수, 문자)을 제공하며, 각 타입은 메모리에서 차지하는 크기와 해석 방식이 다릅니다. Javascript는 null, undefined, boolean, number, string, symbol, bigint 등의 기본 타입을 가집니다.
•
포인터는 메모리 주소를 값으로 가지는 특별한 타입으로, C 언어에서 핵심적인 역할을 하며 간접 주소 지정을 가능하게 합니다. 포인터를 이해하는 것은 컴퓨터 과학 분야에서 매우 중요합니다. 64비트 컴퓨터에서 포인터는 일반적으로 64비트 크기를 가집니다. NULL 포인터(값이 0)는 유효한 메모리 주소로 간주되지 않습니다.
•
일부 언어(예: Java)에서는 포인터 대신 참조를 사용하여 메모리 주소를 추상화하고 안정성을 높입니다.
배열
•
배열은 같은 타입의 원소들이 메모리에 연속적으로 저장되는 기본적인 선형 데이터 구조입니다. 이는 아파트에 비유될 수 있는데, 배열의 각 원소는 아파트의 각 호실에 해당하고, 인덱스는 호수에 해당합니다.
•
다차원 배열은 층마다 여러 개의 집이 있는 아파트와 유사하게 생각할 수 있습니다.
•
배열을 사용할 때는 참조 지역성을 고려하는 것이 중요합니다. 참조 지역성이란 최근에 접근한 메모리 위치나 그 주변의 위치에 다시 접근할 가능성이 높다는 원리입니다. 배열은 연속된 메모리 공간에 데이터를 저장하므로 공간적 지역성이 높습니다. 행 우선 저장 방식에서 행 인덱스가 바뀔 때 열 인덱스가 바뀔 때보다 메모리 이동이 더 많이 일어납니다.
•
배열의 인덱스가 할당된 범위를 벗어나지 않도록 주의해야 하며, 그렇지 않으면 프로그램이 오류를 일으키거나 의도하지 않은 메모리 영역에 접근할 수 있습니다. 일부 프로그래밍 언어(예: 파스칼)는 배열 인덱스 범위를 검사합니다.
•
일반적인 배열(밀집 배열)은 동일한 크기의 메모리 공간이 연속적으로 나열된 구조이지만, Javascript의 배열은 내부적으로 다를 수 있습니다.
비트맵
•
비트맵은 비트의 배열로, 작은 크기의 데이터를 효율적으로 관리하거나 여러 상태를 추적하는 데 유용합니다. 예를 들어, 각 비트를 통해 두 가지 상태(참/거짓, 사용 가능/불가능)를 나타낼 수 있습니다.
•
비트맵에서 수행할 수 있는 기본적인 연산으로는 비트 설정(set), 비트 지우기(clear), 비트가 1인지 검사, 비트가 0인지 검사 등이 있습니다.
•
특정 비트의 위치를 찾기 위해서는 정수 나눗셈과 비트 연산을 활용합니다. 비트 번호를 8로 나누어 해당 비트가 포함된 바이트를 찾고, 마스크를 사용하여 해당 바이트 내에서 특정 비트를 선택하거나 조작합니다. 마스크는 특정 비트를 '들여다볼 수 있는' 구멍이 있는 비트 패턴입니다.
•
비트 연산을 통해 비트를 설정(OR 연산), 지우기(AND와 NOT 연산), 검사(AND 연산 후 0과 비교)할 수 있습니다.
•
비트맵은 자원(예: 디스크 블록, 메모리 블록)의 사용 여부를 추적하는 데 효율적입니다.
문자열
•
문자열은 여러 문자로 이루어진 시퀀스입니다.
•
문자열을 저장하고 연산하기 위해서는 문자열의 길이를 알아야 합니다.
•
문자열 길이를 관리하는 방법으로는 첫 번째 바이트에 문자열 길이를 저장하는 방식과 **문자열의 끝에 NUL 문자(문자열 터미네이터)**를 추가하는 방식이 있습니다. 첫 번째 방식은 길이를 빠르게 알 수 있지만 문자열 길이에 제한이 있고 메모리 정렬 문제를 야기할 수 있습니다. C 언어는 후자의 방식을 사용하며, 문자열 길이를 별도로 저장하지 않고 NUL 문자로 문자열의 끝을 표시합니다.
•
C 언어에서 문자열은 **1차원 바이트 배열(char[])**로 처리됩니다. NUL 문자를 사용하는 방식은 문자열 저장이 간편하고 대부분의 기계에서 0 값 검사가 효율적이지만, 문자열 길이를 알기 위해서는 문자열 전체를 스캔해야 하고 문자열 중간에 NUL 문자를 포함할 수 없다는 단점이 있습니다.
•
최근의 프로그래밍 언어들은 문자열의 길이와 내용을 함께 관리하는 문자열 객체를 사용하는 경우가 많습니다.
복합 데이터 타입
•
복합 데이터 타입은 기본 데이터 타입을 조합하여 새로운 데이터 타입을 만드는 것으로, 대표적으로 **구조체(struct)**와 **공용체(union)**가 있습니다.
•
구조체는 **여러 개의 변수(멤버)**를 하나의 단위로 묶어 다양한 타입의 데이터를 함께 관리할 수 있도록 합니다. 이는 호텔 스위트룸에 비유될 수 있으며, 각 방이 구조체의 멤버에 해당합니다. 구조체는 프로그래밍 언어에서 더 근본적인 요소로 여겨집니다.
•
프로그래밍 언어는 구조체의 멤버 순서를 유지하지만, 메모리 정렬을 위해 멤버 사이에 패딩을 추가하여 예상보다 많은 메모리를 차지할 수 있습니다. CPU가 특정 크기 단위로 메모리를 읽고 쓰는 것이 효율적이기 때문에 패딩을 통해 데이터가 메모리 경계에 걸치는 것을 방지합니다. 구조체 멤버의 순서를 변경하여 패딩으로 인한 메모리 낭비를 줄일 수도 있습니다.
•
공용체는 같은 메모리 공간을 여러 가지 관점으로 바라볼 수 있도록 하는 데이터 구조로, 모든 멤버가 동일한 메모리 공간을 공유하며 한 번에 하나의 멤버만 값을 가질 수 있습니다. 이는 움직일 수 있는 파티션으로 구분된 사무실과 유사합니다.
단일 연결 리스트
•
단일 연결 리스트는 원소의 개수를 미리 알 수 없거나 데이터 양이 정해져 있지 않은 경우 배열보다 효율적인 선형 데이터 구조입니다.
•
연결 리스트는 여러 개의 노드로 이루어져 있으며, 각 노드는 데이터와 **다음 노드를 가리키는 포인터(next)**를 포함합니다.
•
리스트의 맨 앞 노드를 헤드(head), **맨 마지막 노드를 테일(tail)**이라고 하며, 테일 노드의 next 포인터는 NULL로 설정되어 리스트의 끝을 나타냅니다.
•
배열과 달리 연결 리스트의 원소들은 메모리의 임의의 위치에 존재할 수 있습니다.
•
연결 리스트에서는 원소의 추가 및 삽입이 용이합니다. 헤드 앞에 새로운 원소를 추가하거나, 특정 위치에 새로운 노드를 삽입할 때 포인터만 변경하면 됩니다.
•
원소 삭제 시에는 삭제할 원소의 바로 앞 원소의 next 포인터가 삭제할 원소의 next 포인터가 가리키는 원소를 가리키도록 변경해야 합니다. current 포인터를 사용하여 삭제할 노드를 검색하며 리스트를 순회할 수 있습니다. 이중 간접 주소 지정을 사용하면 삭제 연산을 더 간단하게 구현할 수 있습니다.
•
연결 리스트의 기본 연산(Push, Pop, Shift, Unshift)은 헤드와 테일을 기준으로 노드를 추가하고 제거하는 방식을 정의합니다.
동적 메모리 할당
•
연결 리스트와 같이 크기가 동적으로 변할 수 있는 데이터 구조를 위해서는 동적 메모리 할당이 필요합니다.
•
새로운 노드를 삽입하기 위한 메모리 할당은 힙(heap) 영역에서 이루어집니다. 힙은 데이터 영역 다음에 존재하는 프로그램 런타임 라이브러리가 관리하는 영역입니다. MMU(Memory Management Unit)가 없는 시스템에서는 힙 영역이 프로그램이 사용할 수 있는 모든 데이터 메모리이지만, MMU가 있는 시스템에서는 런타임 라이브러리가 운영체제에 필요한 메모리 용량을 요청합니다.
•
프로그램은 힙을 직접 관리해야 하며, C 언어에서는 malloc 함수를 사용하여 메모리를 할당하고 free 함수를 사용하여 할당된 메모리를 해제합니다.
•
시간이 지남에 따라 힙 영역은 메모리 파편화될 수 있습니다.
•
자바와 같은 언어에서는 가비지 컬렉션을 통해 동적 메모리 관리를 자동화합니다.
가비지 컬렉션
•
가비지 컬렉션은 더 이상 사용하지 않는 동적 할당된 메모리를 자동으로 해제하는 메커니즘입니다.
•
자바와 같은 언어는 포인터 대신 참조를 사용하며, 참조는 포인터를 추상화하여 유사한 기능을 제공하지만 실제 메모리 주소를 노출하지 않습니다.
•
가비지 컬렉션을 사용하는 언어에서는 new 연산자를 통해 데이터 요소를 생성하면서 메모리를 할당하지만, 명시적인 삭제 연산자는 없습니다. 런타임 환경이 변수 사용을 추적하여 더 이상 사용하지 않는 메모리를 자동으로 해제합니다. 대표적인 가비지 컬렉션 방식으로는 참조 카운팅과 루트 집합 기반 추적 등이 있습니다.
•
가비지 컬렉션은 프로그래머가 메모리 관리에 대한 부담을 덜 수 있다는 장점이 있지만, 가비지 컬렉션 시스템을 프로그래머가 직접 제어할 수 없다는 단점이 있습니다. 또한 불필요한 참조가 남아 메모리 재활용을 방해하고 프로그램이 더 많은 메모리를 사용하는 경향이 있으며, 메모리 재활용이 늦어지면 프로그램이 느려질 수 있습니다. 불필요한 참조를 추적하는 작업 또한 디버깅을 더 어렵게 만들 수 있습니다.
•
JVM의 힙 영역은 Young Generation(Eden, Survivor), Old Generation, Metaspace 등으로 나뉘어 객체의 생명주기에 따라 관리되며, Minor GC와 Major GC를 통해 메모리를 정리합니다.
이중 연결 리스트
•
이중 연결 리스트는 각 노드가 다음 원소뿐만 아니라 이전 원소에 대한 포인터도 포함하는 연결 리스트입니다.
•
단일 연결 리스트의 delete 함수에서는 삭제하려는 원소의 바로 앞 원소를 찾아야 하므로 비효율적이지만, 이중 연결 리스트는 이전 노드 포인터를 통해 이러한 탐색 없이 원하는 위치에 노드를 쉽게 추가하거나 삭제할 수 있습니다.
•
노드당 부가 비용은 2배로 증가하지만, 삭제 시 리스트 전체를 순회할 필요가 없어지는 공간/시간 트레이드 오프를 제공합니다.
계층적인 데이터 구조
•
**선형적인 데이터 구조(배열, 연결 리스트)**는 데이터를 찾기 위해 리스트를 순회해야 하므로 효율성이 떨어질 수 있습니다. 리스트의 길이가 n이라면 최악의 경우 n번의 비교가 필요합니다.
•
2진 트리는 가장 간단한 계층적인 데이터 구조로, 각 노드가 최대 두 개의 자식 노드를 가집니다. 2진 트리는 값을 찾기 쉽고, 노드를 가리키는 포인터를 가리키는 포인터를 만들 필요가 없습니다.
•
하지만 비균형 트리는 검색을 어렵게 만들고 최악의 경우 선형 리스트와 다를 바 없으므로, 트리의 균형을 회복하는 알고리즘이 필요합니다. 균형 이진 트리의 검색 시간 복잡도는 O(log N)입니다.
대용량 저장장치
•
디스크의 기본적인 저장 단위는 블록이며, 연속적인 블록을 클러스터라고 합니다. 클러스터는 한 트랙 안에 있는 연속적인 섹터로 이루어져 있습니다.
•
데이터를 디스크에 저장할 때는 연속적인 클러스터에 저장하는 것이 이상적이지만 항상 가능한 것은 아니므로, 운영체제의 장치 드라이버가 데이터를 연속적으로 저장된 것처럼 보이게 해줍니다.
•
데이터를 장기적으로 저장하기 위해서는 파일 이름과 파일 이름과 데이터가 저장된 디스크 블록을 연결해 줄 방법이 필요하며, 유닉스에서는 이를 위해 **아이노드(inode)**를 사용합니다. 아이노드는 디스크 블록에 대한 인덱스와 파일에 대한 여러 가지 정보(이름, 소유자, 크기, 권한 등)를 포함합니다.
•
아이노드는 데이터 블록을 가리키기 위해 직접 블록 포인터(보통 12개), 간접 블록, 2중 간접 블록, 3중 간접 블록 등을 사용하여 최대 4PiB까지 지원할 수 있습니다.
•
유닉스에서는 디렉터리도 파일의 한 유형이며, 이를 통해 계층적인 파일 시스템이 탄생했습니다. 여러 아이노드가 같은 블록을 참조하는 하드 링크와 디렉터리에도 가능한 심볼릭 링크가 존재합니다. 심볼릭 링크는 파일 시스템 그래프에 루프를 생성할 수 있으므로 무한 루프 감지 코드가 필요합니다.
•
가용 공간을 추적하기 위해 각 블록을 1비트로 표현하는 비트맵 방식을 사용하며, 이는 전체 디스크 공간의 작은 부분만을 차지합니다. 과거에는 전원 차단 시 가용 공간 비트맵과 파일 시스템 그래프 간 동기화가 깨질 수 있었지만, 현재는 fsck와 같은 프로그램과 오류 복구 기능을 강화한 저널링 파일 시스템이 널리 사용됩니다.
데이터베이스
•
데이터베이스는 정해진 방식으로 조직화된 데이터 모음이며, B 트리라는 데이터 구조를 활용한 시스템입니다.
•
B 트리는 균형 트리이지만 2진 트리는 아니며, 균형 2진 트리보다 공간 효율성은 떨어지지만 성능이 더 뛰어나고 특히 디스크에 데이터를 저장할 때 더 효율적입니다. B 트리 노드는 디스크 블록 하나를 채울 수 있을 만큼 많은 자식을 가질 수 있으며, 내부 노드가 균형이 잘 잡혀 있어 검색 시간을 미리 예측할 수 있습니다. 노드에 저장하는 키 수가 많을수록 디스크에서 읽어오는 횟수를 줄일 수 있습니다.
인덱스
•
인덱스는 데이터베이스에서 **검색 성능을 향상시키기 위해 구성된 조직화된 노드(주 인덱스)**입니다. 정렬된 데이터는 효율적으로 접근할 수 있습니다.
•
인덱스는 유지보수해야 한다는 트레이드오프가 존재합니다. 데이터가 변경될 때마다 인덱스도 갱신해야 하므로 갱신 비용이 발생하지만, 일반적으로 데이터 변경보다 데이터 검색이 더 자주 발생하므로 이러한 비용은 지불할 가치가 있습니다.
데이터 이동
•
페이지 테이블을 MMU에 입출력하거나 디스크 비트맵을 입출력할 때 데이터 복사가 필요하며, 프로그램은 데이터를 한 지점에서 다른 지점으로 이동시키는 데 시간을 소비하므로 이를 효율화해야 합니다.
•
루프 언롤링은 반복문의 반복 횟수를 줄여서 처리 속도를 높이는 기법으로, 데이터 복사 효율을 높일 수 있습니다. 더프의 장치는 루프 언롤링과 스위치문을 결합한 더 빠른 데이터 복사 방식입니다.
•
64비트 기계는 8바이트를 한 번에 0으로 설정할 수 있습니다. 메모리의 내용을 어떤 값으로 설정하지 않고 데이터 블록으로 복사하려면 원본과 복사본 메모리 경계가 다를 수 있으므로 더 복잡한 검사가 필요하며, 영역이 겹치는 경우에도 주의해야 합니다.
•
**벡터를 사용한 I/O(gathering/scattering)**는 복사를 아예 피하여 성능을 향상시키는 방법입니다. 크기와 데이터에 대한 포인터로 이루어진 벡터를 운영체제에 넘기면 시스템이 데이터를 여러 부분에서 모아 하나로 합치거나 여러 위치로 분산시키는 방식으로 I/O를 처리합니다. TCP/IP도 분산/수집 방식을 사용합니다.
객체 지향의 함정
•
객체 지향 언어를 주의 깊게 사용하지 않으면 성능 문제가 발생할 수 있습니다. 객체는 메서드에 대한 포인터를 가지고 다니며, 객체 내의 데이터가 메모리에서 꽉 짜여 있지 않을 수 있습니다. 성능이 결정적으로 중요할 때는 배열을 활용하는 것이 나을 수 있습니다.
정렬
•
정렬 대상이 포인터 크기보다 크면 데이터를 직접 정렬하는 대신 포인터를 재배열하는 방식으로 정렬하여 데이터 자체가 여기저기로 움직이지 않게 해야 효율적입니다. 정렬은 산술적인 비교로 단순화할 수 있으며, 퀵 정렬과 같은 알고리즘은 포인터를 활용하여 데이터 비교 방식을 알지 못해도 정렬을 수행할 수 있습니다.
해시
•
해싱은 더 나은 검색 성능을 제공합니다. 해시 함수를 키에 적용하여 균일하게 배치하고, 그 결과를 배열 인덱스로 활용하는 해시 테이블을 사용합니다.
•
좋은 해시 함수는 계산하기 쉽고 키를 골고루 버킷에 뿌려줘야 하며, 해시 테이블 크기를 소수로 만드는 것이 좋습니다. 해시 함수의 값이 같으면 충돌이 발생하며, 해시 체인과 같은 방식으로 이를 해결할 수 있습니다. 해시 테이블 확장은 비용이 많이 들지만 검색보다 덜 발생하므로 이득을 볼 수 있습니다.
효율성과 성능
•
예전과 달리 효율과 성능이 분리되는 경향이 있으며, 성능을 높이기 위해 반드시 효율적일 필요는 없습니다.
•
**샤딩(수평 파티셔닝)**은 데이터베이스를 여러 개의 독립적인 샤드로 분할하여 부하를 분산시키고 병렬 처리를 통해 성능과 확장성을 향상시키는 기술입니다.
•
맵리듀스는 대량의 데이터를 분산 처리하기 위한 프로그래밍 모델입니다.
참조 지역성 및 캐시
•
참조 지역성은 컴퓨터가 메모리에 접근하는 패턴으로, 시간적 지역성, 공간적 지역성, 분기 지역성, 등거리 지역성 등이 있습니다.
•
메모리 계층 구조(캐시 - 메인 메모리 - 보조 기억 장치)는 참조 지역성을 이용하여 성능을 향상시킵니다. 캐시는 자주 사용되는 데이터를 가까운 곳에 저장하여 접근 시간을 줄입니다.
•
**평균 메모리 접근 시간(AMAT)**은 캐시 히트 시간, 미스율, 미스 패널티를 이용하여 계산하며, 캐시 효율성을 평가하는 지표입니다.
•
캐시 미스는 프로그램 실행 속도를 저하시키므로, 데이터 지역성을 고려한 알고리즘 설계가 중요합니다. 캐시는 바이트 단위가 아닌 블록 단위로 데이터를 가져오며, 캐시 블록 크기 설정은 성능에 영향을 미칩니다. 캐시 공간이 부족할 경우 **LRU(Least Recently Used)**와 같은 캐시 교체 정책에 따라 데이터를 버립니다.
이처럼 7장에서는 다양한 데이터 구조의 개념과 특징, 그리고 이들이 컴퓨터 시스템의 효율성과 성능에 미치는 영향에 대해 심도 있게 다룹니다. 단순히 자료 구조를 암기하는 것이 아니라, 각 자료 구조가 왜 필요하며, 어떤 상황에서 유리하고 불리한지를 이해하는 것이 중요합니다. 또한 메모리 관리, 디스크 I/O, 캐시와 같은 하드웨어적인 측면과의 연관성을 파악하는 것도 핵심입니다.
