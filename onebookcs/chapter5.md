# 5장: 컴퓨터 아키텍처와 운영체제

## 기본적인 구조 요소들

- 폰 노이먼 vs 하버드 구조

- 폰 노이먼: 단일 메모리 버스로 인한 병목 현상 발생
- 하버드: 명령어/데이터 메모리 분리로 병렬 처리 가능 → DSP, 임베디드 시스템에 활용
- 현대: L1 캐시에서 하버드 방식을 채택한 하이브리드 구조

### 프로세서 코어

- 멀티프로세서, 병렬화(여러 CPU 활용)만으로는 성능 높이기 부족
- 전력 장벽(Power Wall) 극복을 위한 설계


### 마이크로프로세서와 마이크로 컴퓨터

- 마이크로프로세서: 메모리와 I/O가 프로세서 코어와 별도 패키지 -> 큰 시스템에 부품으로 사용
- 마이크로컴퓨터(마이크로컨트롤러): 모든 요소를 한 칩안에 패키징 -> 식기세척기 등에 사용되는 작은 컴퓨터
  - 칩 내부에 메모리가 차지하는 영역이 크기 때문에 마이크로프로세서보다 덜 강력함
- 단일 칩 시스템(System on Chip, SoC): 더 복잡한 마이크로컴퓨터. I/O 대신 WiFi 회로 등 복잡한 장치 내장.
  - 일부 SoC는 FPGA 제공하여 사용자 커스터마이징 가능

## 프로시저, 서브루틴, 함수

- 함수: 코드를 재사용하는 중요한 방법 (== 프로시저, 서브루틴...)
- 함수 호출 시 컴퓨터 내부에서 일어나는 과정
1. 반환 주소 저장
2. 함수 파라미터를 누산기에 저장
3. 함수 작업 수행
4. 함수 반환(간접 분기) 뒤에 실행 계속
5. 반환 주소 반환

> [!NOTE]
> JNI?

## 스택

> [!NOTE]
> 자바 콜스택
> 자스 스택 프레임
> 하드웨어의 스택 오버플로/언더플로 방지를 위한 한계 레지스터 예시



## 인터럽트

인터럽트 시스템에서 주변 장치들은 인터럽트 요청 생성 -> 예시

인터럽트와 컨텍스트 스위칭?

- 인터럽트 처리 과정에서는 응답 시간, 현재 상태 저장, 인터럽트 벡터 등 여러 요소가 고려된다.
- 인터럽트 벡터: 각 인터럽트에 대한 핸들러 주소를 지정하는 포인터 역할
- 인터럽트의 우선순위 설정, 마스킹, 내장 타이머를 통한 주기적 인터럽트 발생 등 다양한 제어 기능이 제공

운영체제는 이러한 하드웨어 인터럽트에 직접 접근할 수 있으며, 소프트웨어 인터럽트 시스템을 제공하기도 한다.
이를 통해 컴퓨터 시스템은 여러 작업을 효율적으로 관리하고, 외부 이벤트에 신속하게 대응할 수 있게 된다. 결과적으로 인터럽트 시스템은 현대 컴퓨터의 핵심 기능으로, 복잡한 작업 처리와 외부 환경과의 상호작용을 가능하게 하는 중요한 메커니즘이다.

## 상대 주소 지정

- 시스템 프로그램 (각 프로그램을 전환시켜 줄 수 있는 일종의 관리자 프로그램)
  - OS, OS 커널
- 사용자 프로그램(프로세스)
  - 시스템 프로그램 외 프로그램
- 시분할 방식: 
- 인덱스 레지스터: 들어있는 값과 명령어의 주소와 더해 유효 주소를 계산
- 상대 주소 지정: 명령어의 주소를 기준으로 하는 상대적인 주소로 해석하는 방식


## 메모리 관리 장치

### MMU(memory management unit)

- 백그라운드 실행 위해 오늘날 대부분 마이크로프로세서에 메모리 관리 장치(MMU)존재 (가상 메모리 주소를 실제 물리적 메모리 위치로 매핑)
- 페이지 테이블
  - 메모리를 페이지로 분할
  - 페이지를 관리하는 RAM의 영역. 이를 통해서 주소를 변환
  - 물리적 메모리에 연관되지 않은 주소에 접근하면 '페이지 폴트' 예외 발생


## 가상 메모리

- OS는 MMU를 사용해 사용자 프로그램에 가상 메모리 제공
- 요청 받은 메모리가 사용 가능한 메모리의 크기보다 클 경우 현재 필요하지 않는 페이지를 디스크로 옮김(스왑 아웃)
- 다시 불러들이는 건 '스왑 인'
- 필요한 페이지만을 물리 메모리에 로드하는 요구 페이징(demand paging) 방식
- 성능 저하 막기 위한 다양한 기법 존재 (LRU 등)

> [!TIP]
> 리눅스 스왑 메모리
> 스왑 메모리: 실제 메모리 RAM이 가득 찼지만 더 많은 메모리가 필요할 때 디스크 공간을 이용하여 부족한 메모리를 제공
> `swapon`, `swappiness` ...


## 시스템공간과 사용자 공간

- CPU에는 시스템 모드에 있는지 사용자 모드에 있는지 결정하는 비트가 레지스터에 들어 있음
- I/O 처리 명령어 등 일부 명령어는 특권 명령어(시스템 모드에서만 실행 가능)
- 트랩이나 시스템 콜을 사용해 시스템 모드 프로그램(운영체제)에 요청 보낼 수 있음
- 사용자 프로그램을 다른 프로그램과 운영체제로부터 보호하고, 운영체제가 자원 할당을 전적으로 제어할 수 있다는 장점


## 메모리 계층과 성능

![image](https://github.com/user-attachments/assets/a50a0018-bb64-4a52-8a10-9f4568620eed)


- CPU의 속도를 따라가지 못하는 메모리 문제를 해결 하기위해 등장한 메모리 계층
- 주 메모리 = RAM: 프로세서보다 느림
- 캐시 메모리를 추가해서 문제 해결(프로그램이 메모리를 순서대로 읽어오고, 자주 사용하는 데이터가 한데 모여 있는 경우가 많음)
- 메모리 컨트롤러 - 메모리에서 연속된 열에 있는 데이터를 한번에 가져옴
- 캐시 히트, 캐시 미스
- 메모리에서 미리 가져오는 프리 페치, 순서를 벗어나는 실행 처리 등 수정을 통해 성능 향상도 가능


## 코프로세서

- 한 칩에서 넣어서 프로세서 코어에서 특정 연산을 분리하여 처리 (그래픽 처리 등)
- DMA: 장치에 데이터 복사 등 귀찮은 일 떠맡겨서 CPU가 유용한 연산을 더 많이 처리할 수 있음


## 메모리 상의 데이터 배치

| 영역 | 용도 | 비고 |
|:--:|:--:|:--:|
| 정적 데이터 영역|프로그램 작성 시점에 그 크기가 결정되는 데이터| 얼마나 많은 메모리가 필요한지 알고 있음|
| 힙 | 동적 데이터 | 주로 정적 데이터가 차지하는 영역 바로 위 영역|
|스택 | 함수 호출 시 지역 변수와 반환 주소를 저장| - |

- 마이크로컴퓨터에는 MMU가 없어서 스택을 맨 위에, 힙을 그 아래에 배치하는 경우가 많음
- 힙과 스택이 충돌하지 않게 하는 것이 중요

> [!NOTE]
> jvm 의 구조?


## 프로그램 실행

- 라이브러리: 함수를 한 데 모은 것
- 한 프로그램의 여러 부분을 동시에 개발할 수 있으므로 여러 조각으로 나눔 -> 조각들을 하나로 엮거나 연결할 링크 필요
- 정적 링크: 라이브러리를 필요한 함수가 들어있는 파일로 간주해서 프로그램의 나머지 부분과 직접 연결해 실행 파일 만듦
- 동적 링크: 공유 라이브러리를 사용하는 동적 링크를 발명
- 프로그램이 실행될때 가장 먼저 실행되는 명령어는 진입점에 있는 명령어가 아님
  - 프로그램을 이루는 모든 부분이 하나로 합쳐져서 실행파일을 이룰 때 런타임 라이브러리가 추가되며
  - 이 런타임 라이브러리에 있는 명령어가 실행되고 나서 진입점의 명령어가 실행됨


