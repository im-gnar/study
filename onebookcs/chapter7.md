# 7장: 데이터 구성

## 기본 데이터 타입과 포인터

- **기본 데이터 타입**
  - 프로그래밍 언어는 정수, 실수, 문자 등 기본 데이터 타입 제공
  - 각 타입은 메모리에서 차지하는 크기와 해석 방식이 다름
  - JavaScript는 null, undefined, boolean, number, string, symbol, bigint 등의 기본 타입 제공
- **포인터**
  - 메모리 주소를 값으로 가지는 특별한 타입
  - C 언어에서 핵심적인 역할을 하며 간접 주소 지정을 가능하게 함
  - 64비트 컴퓨터에서 포인터는 일반적으로 64비트 크기
  - NULL 포인터(값이 0)는 유효한 메모리 주소로 간주되지 않음
- **참조**
  - Java 등의 언어에서는 포인터 대신 참조를 사용
  - 메모리 주소를 추상화하고 안전성을 높임

> [!NOTE]
> 포인터와 참조의 차이는 무엇인가?
> <br>포인터는 메모리 주소를 직접 조작할 수 있는 반면, 참조는 메모리 주소를 추상화하여 안전성을 높인 개념
> <br>포인터는 산술 연산(증가, 감소)이 가능하지만, 참조는 불가능
> <br>포인터는 NULL 값을 가질 수 있지만, Java의 참조는 기본적으로 null 체크가 없어 NullPointerException 발생 가능

## 선형 데이터 구조

### 배열

- **기본 특성**
  - 같은 타입의 원소들이 메모리에 연속적으로 저장되는 기본적인 선형 데이터 구조
  - 아파트에 비유: 각 원소는 아파트의 각 호실, 인덱스는 호수에 해당
  - 다차원 배열은 층마다 여러 개의 집이 있는 아파트와 유사
- **참조 지역성**
  - 최근에 접근한 메모리 위치나 그 주변의 위치에 다시 접근할 가능성이 높음
  - 배열은 연속된 메모리 공간에 데이터를 저장하므로 공간적 지역성이 높음
  - 행 우선 저장 방식에서 행 인덱스가 바뀔 때 열 인덱스가 바뀔 때보다 메모리 이동이 더 많이 발생
- **인덱스 범위**
  - 배열의 인덱스가 할당된 범위를 벗어나지 않도록 주의
  - 범위를 벗어나면 프로그램 오류 또는 의도하지 않은 메모리 영역에 접근 가능
  - 일부 언어(예: 파스칼)는 배열 인덱스 범위를 검사
- **구현 차이**
  - 일반적인 배열(밀집 배열)은 동일한 크기의 메모리 공간이 연속적으로 나열된 구조
  - JavaScript의 배열은 내부적으로 해시 테이블로 구현되어 있어 다른 특성을 가짐

### 비트맵

- **개념**
  - 비트의 배열로, 작은 크기의 데이터를 효율적으로 관리
  - 각 비트로 두 가지 상태(참/거짓, 사용 가능/불가능)를 나타낼 수 있음
- **기본 연산**
  - 비트 설정(set), 비트 지우기(clear), 비트가 1인지 검사, 비트가 0인지 검사
  - 특정 비트 위치 찾기: 정수 나눗셈과 비트 연산 활용
  - 비트 번호를 8로 나누어 해당 비트가 포함된 바이트 찾기
  - 마스크를 사용하여 바이트 내 특정 비트 선택/조작
- **비트 연산**
  - 비트 설정: OR 연산
  - 비트 지우기: AND와 NOT 연산
  - 비트 검사: AND 연산 후 0과 비교
- **활용**
  - 자원(디스크 블록, 메모리 블록)의 사용 여부 추적에 효율적

### 문자열

- **정의**
  - 여러 문자로 이루어진 시퀀스
- **길이 관리 방법**
  - 첫 번째 바이트에 문자열 길이 저장: 길이 빠르게 알 수 있으나 제한 있음
  - NUL 문자(문자열 터미네이터) 추가: C 언어 방식
- **C 언어 문자열**
  - 1차원 바이트 배열(char[])로 처리
  - NUL 문자로 문자열 끝 표시
  - 장점: 저장 간편, 0 값 검사 효율적
  - 단점: 길이 알기 위해 전체 스캔 필요, 중간에 NUL 문자 포함 불가
- **최신 언어**
  - 문자열의 길이와 내용을 함께 관리하는 문자열 객체 사용
  - 더 효율적인 문자열 연산 제공

## 복합 데이터 타입

### 구조체(struct)

- **개념**
  - 여러 개의 변수(멤버)를 하나의 단위로 묶어 관리
  - 호텔 스위트룸에 비유: 각 방이 구조체의 멤버에 해당
- **메모리 정렬**
  - 구조체 멤버 사이에 패딩 추가로 예상보다 많은 메모리 차지 가능
  - CPU가 특정 크기 단위로 메모리 읽고 쓰는 것이 효율적
  - 패딩으로 데이터가 메모리 경계에 걸치는 것 방지
  - 구조체 멤버 순서 변경으로 패딩 메모리 낭비 줄일 수 있음

### 공용체(union)

- **개념**
  - 같은 메모리 공간을 여러 관점으로 바라볼 수 있는 데이터 구조
  - 모든 멤버가 동일한 메모리 공간 공유
  - 한 번에 하나의 멤버만 값을 가질 수 있음
  - 움직일 수 있는 파티션으로 구분된 사무실과 유사

## 연결 리스트

### 단일 연결 리스트

- **특징**
  - 원소 개수를 미리 알 수 없거나 데이터 양이 정해지지 않은 경우 효율적
  - 각 노드는 데이터와 다음 노드를 가리키는 포인터(next) 포함
  - 맨 앞 노드는 헤드(head), 맨 마지막 노드는 테일(tail)
  - 테일 노드의 next 포인터는 NULL로 설정하여 리스트 끝 표시
  - 배열과 달리 원소들은 메모리의 임의 위치에 존재 가능
- **주요 연산**
  - 원소 추가/삽입: 포인터만 변경하면 됨
  - 원소 삭제: 이전 원소의 next 포인터를 변경하여 건너뛰기
  - 기본 연산: Push, Pop(스택), Shift, Unshift(큐)

### 이중 연결 리스트

- **특징**
  - 각 노드가 다음 원소와 이전 원소 포인터 모두 포함
  - 단일 연결 리스트보다 노드 삭제 연산이 효율적
  - 이전 노드 포인터로 탐색 없이 원하는 위치에 노드 추가/삭제 가능
- **트레이드오프**
  - 노드당 부가 비용 2배 증가
  - 삭제 시 리스트 전체 순회 필요 없음

## 동적 메모리 관리

### 동적 메모리 할당

- **필요성**
  - 연결 리스트 같이 크기가 동적으로 변하는 데이터 구조를 위해 필요
- **힙(heap) 영역**
  - 새로운 노드 삽입을 위한 메모리 할당은 힙 영역에서 이루어짐
  - 데이터 영역 다음에 존재하는 프로그램 런타임 라이브러리가 관리
  - MMU가 없는 시스템: 프로그램이 사용할 수 있는 모든 데이터 메모리
  - MMU가 있는 시스템: 런타임 라이브러리가

# 계층적 데이터 구조

## 이진 트리

- **특징**
  - 선형 데이터 구조(배열, 연결 리스트)는 검색에 비효율적
  - 가장 간단한 계층적 데이터 구조
  - 각 노드가 최대 두 개의 자식 노드 가짐
  - 값 찾기 쉬움
  - 이중 간접 주소 지정 불필요
- **균형 트리**
  - 비균형 트리는 최악의 경우 선형 리스트와 유사
  - 균형 회복 알고리즘 필요
  - 균형 이진 트리의 검색 시간 복잡도: O(log N)
- **이진 검색 트리(BST)**
  - 각 노드는 왼쪽 서브트리의 모든 값보다 큰 값을 가짐
  - 각 노드는 오른쪽 서브트리의 모든 값보다 작은 값을 가짐
  - 중위 순회(in-order traversal)하면 정렬된 순서로 값을 얻을 수 있음
  - 평균적인 검색, 삽입, 삭제 시간 복잡도: O(log N)
  - 최악의 경우(한쪽으로 치우친 트리): O(N)
- **자가 균형 이진 검색 트리**
  - AVL 트리: 왼쪽과 오른쪽 서브트리의 높이 차이가 최대 1
  - 레드-블랙 트리: 각 노드는 빨간색 또는 검은색, 특정 규칙으로 균형 유지
  - 스플레이 트리: 최근 접근한 노드를 루트로 이동시켜 접근 속도 향상

> [!NOTE]
> **이진 트리**
> - 트리 순회 알고리즘(전위, 중위, 후위) 구현
> - 균형 이진 트리 재조정 알고리즘
> - 컴파일러의 추상 구문 트리(AST) 구현
> - 힙(Heap) 자료구조와 우선순위 큐 구현
> - 트라이(Trie) 구조와 문자열 검색 최적화

## B 트리

- **특징**
  - 균형 트리이지만 이진 트리는 아님
  - 균형 이진 트리보다 공간 효율성은 떨어지나 성능 우수
  - 디스크 데이터 저장에 효율적
  - 노드가 디스크 블록 하나를 채울만큼 많은 자식 가능
  - 내부 노드 균형 잘 잡혀 검색 시간 예측 가능
  - 노드 저장 키 수가 많을수록 디스크 읽기 횟수 감소
- **B+ 트리**
  - B 트리의 변형으로 데이터베이스 인덱싱에 최적화
  - 모든 데이터는 리프 노드에만 저장
  - 리프 노드들은 연결 리스트로 연결되어 순차 접근 가능
  - 내부 노드는 인덱스 역할만 수행하여 더 많은 키 저장 가능
- **응용 분야**
  - 관계형 데이터베이스의 인덱스 구현
  - 파일 시스템(예: NTFS, ext4)
  - 공간 효율적인 정렬된 데이터 저장

> [!TIP]
> **B 트리 최적화 전략**
> - 노드 크기를 디스크 블록 크기와 일치시켜 I/O 효율성 극대화
> - 키 분할 및 병합 전략 조정으로 트리 재구성 비용 최소화
> - 메모리 내 B 트리와 디스크 기반 B 트리의 설계 차이점 이해
> - 데이터베이스 인덱스 크기에 따른 B 트리 차수 최적화
> - 대용량 데이터셋에서 B 트리의 효율적인 벌크 로딩 기법


# 파일 시스템과 저장

## 대용량 저장장치

- **기본 단위**
  - 블록: 디스크의 기본 저장 단위
  - 클러스터: 연속적인 블록
  - 클러스터는 한 트랙 내 연속적인 섹터로 구성
- **데이터 저장**
  - 연속적인 클러스터에 저장이 이상적이나 항상 가능하지 않음
  - 운영체제 장치 드라이버가 연속적으로 저장된 것처럼 보이게 함
- **파일 시스템**
  - 파일 이름과 저장된 디스크 블록 연결 방법 필요
  - 유닉스는 아이노드(inode) 사용
  - 아이노드: 디스크 블록 인덱스와 파일 정보(이름, 소유자, 크기, 권한) 포함
  - 직접 블록 포인터, 간접 블록, 2중/3중 간접 블록으로 최대 4PiB 지원
- **디렉터리 구조**
  - 유닉스에서 디렉터리도 파일의 한 유형
  - 계층적 파일 시스템 구현
  - 하드 링크: 여러 아이노드가 같은 블록 참조
  - 심볼릭 링크: 디렉터리에도 가능, 파일 시스템 그래프에 루프 생성 가능
- **가용 공간 관리**
  - 비트맵 방식: 각 블록을 1비트로 표현
  - 전체 디스크 공간의 작은 부분만 차지
  - 저널링 파일 시스템: 오류 복구 기능 강화

> [!NOTE]
> **저장장치 기술 심화 학습**
> - 플래시 메모리와 SSD의 내부 작동 원리와 특성(마모 레벨링, 가비지 컬렉션)
> - 디스크 스케줄링 알고리즘(FCFS, SSTF, SCAN, C-SCAN, LOOK)의 비교
> - RAID 레벨별 특징과 적용 사례
> - NVMe와 기존 SATA/SAS 인터페이스의 성능 차이와
> - 단일 레벨 셀(SLC)과 다중 레벨 셀(MLC, TLC, QLC) 기술 비교

## 파일 시스템의 진화

- **FAT (File Allocation Table)**
  - MS-DOS, 초기 Windows에서 사용
  - 파일 할당 테이블을 통해 클러스터 체인 관리
  - 단순한 구조지만 대용량 파일 시스템에서 비효율적
- **NTFS (NT File System)**
  - Windows NT 이후 표준 파일 시스템
  - Master File Table (MFT)를 통한 메타데이터 관리
  - 저널링, 암호화, 접근 제어 등 고급 기능 지원
- **ext4 (Fourth Extended File System)**
  - Linux의 표준 파일 시스템
  - 아이노드 기반, 저널링 지원
  - 대용량 파일과 파일 시스템 지원 (최대 1 EiB)
- **ZFS (Zettabyte File System)**
  - Sun Microsystems가 개발한 고급 파일 시스템
  - 데이터 무결성, 스냅샷, 데이터 중복 제거 등 지원
  - 소프트웨어 RAID, 볼륨 관리 기능 통합

> [!TIP]
> **현대 파일 시스템 최적화 전략**
> - 파일 시스템 튜닝 파라미터(저널링 설정, 블록 크기, 인덱싱 방식)
> - Copy-on-Write(CoW) 파일 시스템의 장단점(Btrfs, ZFS)
> - 대용량 파일 처리를 위한 효율적인 입출력 기법
> - 클라우드 환경의 분산 파일 시스템(HDFS, GFS, Ceph) 아키텍처
> - 암호화 파일 시스템과 성능 영향 분석


# 데이터베이스

## 기본 구조

- **정의**
  - 정해진 방식으로 조직화된 데이터 모음
  - B 트리 데이터 구조 활용 시스템
- **관계형 데이터베이스**
  - 테이블(관계)로 데이터 구성
  - 각 테이블은 행(레코드)과 열(필드)로 구성
  - SQL(Structured Query Language)로 데이터 조작
  - ACID 트랜잭션 보장
    - Atomicity(원자성): 트랜잭션은 전부 실행되거나 전혀 실행되지 않음
    - Consistency(일관성): 트랜잭션 실행 전후로 데이터베이스는 일관된 상태 유지
    - Isolation(격리성): 동시에 실행되는 트랜잭션은 서로 격리됨
    - Durability(지속성): 완료된 트랜잭션은 영구적으로 반영됨
- **NoSQL 데이터베이스**
  - 비관계형 데이터 저장에 최적화
  - 주요 유형
    - 문서 지향(MongoDB): JSON 같은 문서 형태로 데이터 저장
    - 키-값 저장소(Redis): 단순한 키-값 쌍으로 데이터 저장
    - 컬럼 기반(Cassandra): 컬럼 단위로 데이터 저장, 대용량 분석에 유리
    - 그래프 데이터베이스(Neo4j): 노드와 관계로 데이터 저장, 관계 분석에 유리

> [!NOTE]
> **데이터베이스 아키텍처 심화 학습**
> - 다양한 데이터베이스 엔진(MyISAM, InnoDB, PostgreSQL 등)의 구조적 차이
> - 트랜잭션 격리 수준과 동시성 제어 메커니즘
> - 데이터베이스 스키마 설계와 정규화/비정규화 전략
> - 분산 데이터베이스 시스템의 샤딩과 레플리케이션 전략
> - 데이터베이스 버퍼 풀 관리와 메모리 최적화 기법

## 인덱스

- **목적**
  - 검색 성능 향상을 위해 구성된 조직화된 노드(주 인덱스)
  - 정렬된 데이터는 효율적으로 접근 가능
- **유형**
  - 기본 인덱스(Primary Index): 테이블의 기본 키에 대한 인덱스
  - 보조 인덱스(Secondary Index): 기본 키가 아닌 필드에 대한 인덱스
  - 클러스터형 인덱스: 데이터 레코드 자체가 인덱스에 의해 물리적으로 정렬됨
  - 비클러스터형 인덱스: 인덱스와 데이터 레코드가 별도로 저장됨
- **인덱싱 기법**
  - B-Tree/B+ Tree 인덱스: 가장 일반적인 인덱싱 방법
  - 해시 인덱스: 해시 함수를 사용한 빠른 검색
  - 비트맵 인덱스: 카디널리티가 낮은 컬럼에 효율적
  - 전문(Full-text) 인덱스: 텍스트 검색에 최적화
- **트레이드오프**
  - 데이터 변경 시마다 인덱스 갱신 필요
  - 갱신 비용 발생하나 검색이 더 빈번하므로 가치 있음
  - 인덱스가 많을수록 검색은 빨라지나 삽입/수정/삭제는 느려짐

> [!TIP]
> **인덱스 최적화 전략**
> - 복합 인덱스 설계와 인덱스 선택도(Selectivity) 분석
> - 쿼리 실행 계획과 인덱스 활용도 평가 방법
> - 인덱스 단편화 모니터링과 재구성 전략
> - 데이터베이스 워크로드 패턴에 따른 인덱스 설계
> - 인덱스 커버링 쿼리와 인덱스 온리 스캔 최적화


# 성능 최적화 기법

## 데이터 이동

- **중요성**
  - 페이지 테이블 MMU 입출력, 디스크 비트맵 입출력 시 데이터 복사 필요
  - 데이터 이동에 상당한 시간 소비
- **최적화 기법**
  - 루프 언롤링: 반복문 횟수 줄여 처리 속도 향상
  - 더프의 장치: 루프 언롤링과 스위치문 결합한 빠른 복사 방식
  - 64비트 기계는 8바이트를 한 번에 0으로 설정 가능
- **메모리 정렬**
  - CPU는 자연스러운 경계(4바이트, 8바이트)에 맞추어 데이터 접근 시 더 효율적
  - 정렬되지 않은 메모리 접근은 여러 메모리 사이클 필요
  - 구조체 필드 배치 시 메모리 정렬 고려 필요
- **벡터 I/O**
  - 복사를 피해 성능 향상
  - gathering/scattering 방식
  - 크기와 데이터 포인터로 구성된 벡터를 OS에 전달
  - 시스템이 여러 부분에서 데이터 모아 합치거나 분산
  - TCP/IP도 분산/수집 방식 사용

> [!NOTE]
> **데이터 이동 최적화 심화 학습**
> - CPU 벡터화 명령어(SSE, AVX)를 이용한 병렬 데이터 처리
> - 제로 카피(Zero-copy) I/O 기법과 구현 방법
> - DMA(Direct Memory Access)의 작동 원리와 활용
> - 메모리 정렬과 패딩이 캐시 성능에 미치는 영향
> - SIMD(Single Instruction Multiple Data) 프로그래밍 기법

## 참조 지역성 및 캐시

- **참조 지역성 종류**
  - 시간적 지역성: 최근 접근한 메모리 위치에 다시 접근할 가능성 높음
  - 공간적 지역성: 인접 메모리 위치에 접근할 가능성 높음
  - 분기 지역성: 조건문이나 루프와 같은 분기 명령어에서 동일한 분기 경로 자주 사용
  - 등거리 지역성: 일정한 간격으로 메모리 위치에 접근하는 패턴
- **메모리 계층 구조**
  - L1 캐시 - L2 캐시 - L3 캐시 - 메인 메모리 - 보조 기억 장치
  - 참조 지역성 이용해 성능 향상
  - 캐시: 자주 사용 데이터를 가까운 곳에 저장하여 접근 시간 단축
- **평균 메모리 접근 시간(AMAT)**
  - AMAT = 히트 시간 + (미스율 × 미스 패널티)
  - 캐시 효율성 평가 지표
  - 캐시 미스 비용이 매우 높기 때문에 미스율 최소화가 중요
- **캐시 최적화**
  - 캐시 미스가 프로그램 실행 속도 저하
  - 데이터 지역성 고려한 알고리즘 설계 중요
  - 캐시는 블록 단위로 데이터 가져옴
  - 캐시 블록 크기 설정이 성능에 영향
  - 캐시 공간 부족 시 LRU(Least Recently Used) 등의 교체 정책 사용
- **캐시 일관성**
  - 멀티코어/멀티프로세서 환경에서 여러 캐시 간 데이터 일관성 유지 필요
  - MESI 프로토콜 등을 통해 캐시 일관성 보장
  - 캐시 무효화(invalidation)와 업데이트 메커니즘

> [!TIP]
> **캐시 최적화 전략**
> - 캐시 블록킹과 타일링 기법을 통한 행렬 연산 최적화
> - 데이터 구조 재배치를 통한 캐시 지역성 향상 방법
> - 캐시 프리페칭(Prefetching) 명령어와 하드웨어 지원 활용
> - 거짓 공유(False Sharing) 현상과 방지 기법
> - 프로세서 아키텍처별 캐시 특성에 맞는 최적화 접근법

## 기타 최적화 기법

- **객체 지향 주의점**
  - 객체지향 언어 주의하지 않으면 성능 문제 발생
  - 객체는 메서드에 대한 포인터 유지
  - 객체 내 데이터가 메모리에서 꽉 짜여있지 않을 수 있음
  - 성능이 중요할 때는 배열 활용이 나을 수 있음
- **정렬 최적화**
  - 정렬 대상이 포인터 크기보다 크면 포인터 재배열 방식이 효율적
  - 데이터 자체 이동 최소화
  - 퀵 정렬 등은 포인터로 데이터 비교 방식을 몰라도 정렬 가능
- **해시 기법**
  - 더 나은 검색 성능 제공
  - 해시 함수를 키에 적용하여 균일하게 배치
  - 결과를 배열 인덱스로 활용하는 해시 테이블 사용
  - 좋은 해시 함수: 계산 쉽고 키를 골고루 버킷에 분배
  - 해시 테이블 크기는 소수가 좋음
  - 충돌 해결: 체이닝, 개방 주소법(선형 탐사, 이차 탐사, 더블 해싱)
- **확장성 기술**
  - 샤딩(수평 파티셔닝): DB를 여러 독립적 샤드로 분할하여 부하 분산
  - 맵리듀스: 대량 데이터 분산 처리 프로그래밍 모델
  - 분산 캐싱: 여러 서버에 데이터 캐싱하여 접근 속도 향상
  - 로드 밸런싱: 여러 컴퓨팅 자원에 작업 분산

> [!NOTE]
> **성능 최적화**
> - 현대 프로세서의 분기 예측(Branch Prediction)과 최적화 기법
> - JIT(Just-In-Time) 컴파일러의 최적화 방식과 한계
> - 락 프리(Lock-free) 알고리즘과 동시성 프로그래밍 최적화
> - 메모리 배리어(Memory Barrier)와 명령어 재배치(Instruction Reordering)
> - 병렬 처리와 스케일링을 위한 아마달의 법칙(Amdahl's Law) 분석

