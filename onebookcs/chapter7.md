# 7장: 데이터 구성

## 기본 데이터 타입과 포인터

- **기본 데이터 타입**
  - 프로그래밍 언어는 정수, 실수, 문자 등 기본 데이터 타입 제공
  - 각 타입은 메모리에서 차지하는 크기와 해석 방식이 다름
  - JavaScript는 null, undefined, boolean, number, string, symbol, bigint 등의 기본 타입 제공
- **포인터**
  - 메모리 주소를 값으로 가지는 특별한 타입
  - C 언어에서 핵심적인 역할을 하며 간접 주소 지정을 가능하게 함
  - 64비트 컴퓨터에서 포인터는 일반적으로 64비트 크기
  - NULL 포인터(값이 0)는 유효한 메모리 주소로 간주되지 않음
- **참조**
  - Java 등의 언어에서는 포인터 대신 참조를 사용
  - 메모리 주소를 추상화하고 안전성을 높임

> [!NOTE]
> 포인터와 참조의 차이는 무엇인가?
> <br>포인터는 메모리 주소를 직접 조작할 수 있는 반면, 참조는 메모리 주소를 추상화하여 안전성을 높인 개념
> <br>포인터는 산술 연산(증가, 감소)이 가능하지만, 참조는 불가능
> <br>포인터는 NULL 값을 가질 수 있지만, Java의 참조는 기본적으로 null 체크가 없어 NullPointerException 발생 가능

## 선형 데이터 구조

### 배열

- **기본 특성**
  - 같은 타입의 원소들이 메모리에 연속적으로 저장되는 기본적인 선형 데이터 구조
  - 아파트에 비유: 각 원소는 아파트의 각 호실, 인덱스는 호수에 해당
  - 다차원 배열은 층마다 여러 개의 집이 있는 아파트와 유사
- **참조 지역성**
  - 최근에 접근한 메모리 위치나 그 주변의 위치에 다시 접근할 가능성이 높음
  - 배열은 연속된 메모리 공간에 데이터를 저장하므로 공간적 지역성이 높음
  - 행 우선 저장 방식에서 행 인덱스가 바뀔 때 열 인덱스가 바뀔 때보다 메모리 이동이 더 많이 발생
- **인덱스 범위**
  - 배열의 인덱스가 할당된 범위를 벗어나지 않도록 주의
  - 범위를 벗어나면 프로그램 오류 또는 의도하지 않은 메모리 영역에 접근 가능
  - 일부 언어(예: 파스칼)는 배열 인덱스 범위를 검사
- **구현 차이**
  - 일반적인 배열(밀집 배열)은 동일한 크기의 메모리 공간이 연속적으로 나열된 구조
  - JavaScript의 배열은 내부적으로 해시 테이블로 구현되어 있어 다른 특성을 가짐

### 비트맵

- **개념**
  - 비트의 배열로, 작은 크기의 데이터를 효율적으로 관리
  - 각 비트로 두 가지 상태(참/거짓, 사용 가능/불가능)를 나타낼 수 있음
- **기본 연산**
  - 비트 설정(set), 비트 지우기(clear), 비트가 1인지 검사, 비트가 0인지 검사
  - 특정 비트 위치 찾기: 정수 나눗셈과 비트 연산 활용
  - 비트 번호를 8로 나누어 해당 비트가 포함된 바이트 찾기
  - 마스크를 사용하여 바이트 내 특정 비트 선택/조작
- **비트 연산**
  - 비트 설정: OR 연산
  - 비트 지우기: AND와 NOT 연산
  - 비트 검사: AND 연산 후 0과 비교
- **활용**
  - 자원(디스크 블록, 메모리 블록)의 사용 여부 추적에 효율적

### 문자열

- **정의**
  - 여러 문자로 이루어진 시퀀스
- **길이 관리 방법**
  - 첫 번째 바이트에 문자열 길이 저장: 길이 빠르게 알 수 있으나 제한 있음
  - NUL 문자(문자열 터미네이터) 추가: C 언어 방식
- **C 언어 문자열**
  - 1차원 바이트 배열(char[])로 처리
  - NUL 문자로 문자열 끝 표시
  - 장점: 저장 간편, 0 값 검사 효율적
  - 단점: 길이 알기 위해 전체 스캔 필요, 중간에 NUL 문자 포함 불가
- **최신 언어**
  - 문자열의 길이와 내용을 함께 관리하는 문자열 객체 사용
  - 더 효율적인 문자열 연산 제공

## 복합 데이터 타입

### 구조체(struct)

- **개념**
  - 여러 개의 변수(멤버)를 하나의 단위로 묶어 관리
  - 호텔 스위트룸에 비유: 각 방이 구조체의 멤버에 해당
- **메모리 정렬**
  - 구조체 멤버 사이에 패딩 추가로 예상보다 많은 메모리 차지 가능
  - CPU가 특정 크기 단위로 메모리 읽고 쓰는 것이 효율적
  - 패딩으로 데이터가 메모리 경계에 걸치는 것 방지
  - 구조체 멤버 순서 변경으로 패딩 메모리 낭비 줄일 수 있음

### 공용체(union)

- **개념**
  - 같은 메모리 공간을 여러 관점으로 바라볼 수 있는 데이터 구조
  - 모든 멤버가 동일한 메모리 공간 공유
  - 한 번에 하나의 멤버만 값을 가질 수 있음
  - 움직일 수 있는 파티션으로 구분된 사무실과 유사

## 연결 리스트

### 단일 연결 리스트

- **특징**
  - 원소 개수를 미리 알 수 없거나 데이터 양이 정해지지 않은 경우 효율적
  - 각 노드는 데이터와 다음 노드를 가리키는 포인터(next) 포함
  - 맨 앞 노드는 헤드(head), 맨 마지막 노드는 테일(tail)
  - 테일 노드의 next 포인터는 NULL로 설정하여 리스트 끝 표시
  - 배열과 달리 원소들은 메모리의 임의 위치에 존재 가능
- **주요 연산**
  - 원소 추가/삽입: 포인터만 변경하면 됨
  - 원소 삭제: 이전 원소의 next 포인터를 변경하여 건너뛰기
  - 기본 연산: Push, Pop(스택), Shift, Unshift(큐)

### 이중 연결 리스트

- **특징**
  - 각 노드가 다음 원소와 이전 원소 포인터 모두 포함
  - 단일 연결 리스트보다 노드 삭제 연산이 효율적
  - 이전 노드 포인터로 탐색 없이 원하는 위치에 노드 추가/삭제 가능
- **트레이드오프**
  - 노드당 부가 비용 2배 증가
  - 삭제 시 리스트 전체 순회 필요 없음

## 동적 메모리 관리

### 동적 메모리 할당

- **필요성**
  - 연결 리스트 같이 크기가 동적으로 변하는 데이터 구조를 위해 필요
- **힙(heap) 영역**
  - 새로운 노드 삽입을 위한 메모리 할당은 힙 영역에서 이루어짐
  - 데이터 영역 다음에 존재하는 프로그램 런타임 라이브러리가 관리
  - MMU가 없는 시스템: 프로그램이 사용할 수 있는 모든 데이터 메모리
  - MMU가 있는 시스템: 런타임 라이브러리가
