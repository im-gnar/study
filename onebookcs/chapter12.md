# 12장: 병렬성과 비동기성

## 경합 조건(race condition)

- 둘 이상의 프로그램/스레드가 같은 자원에 동시 접근 시 실행 순서에 따라 결과가 달라지는 현상
  - 예: 은행 계좌에서 동시 인출 시 잔액 오류
- 공유 자원: 메모리, I/O 장치 (프린터, USB, FPGA), 네트워크 소켓 등


> [!NOTE]
> IPC(Inter-Process Communication)

## 프로세스와 스레드

- 프로세스: 독립적인 메모리 공간을 갖는 실행 단위
- 스레드: 프로세스 내에서 실행되는 경량 단위 (Lightweight Process)
- 공유: heap, static
- 독립: stack, register
- 문맥 전환 비용: 프로세스 > 스레드

> [!NOTE]
>  TCB(Thread Control Block), PCB(Process Control Block) 


- 프로세스: 사용자 공간에서 실행 중인 프로그램
  - 경합 조건이 발생하려면 병렬로 실행되는 프로그램이 자원을 공유해야 함
- 스레드: 정적인 데이터와 힙을 공유하지만 자체적으로 스택을 갖는 프로그램의 일부분
  - 처음부터 끝까지 한번에 끝나는 간단한 작업이 아님(중간에 사용자 입력을 기다리는 등)
- 서로 협력하는 프로세스들로는 데이터 공유가 불가능
- 핸들러 인터럽트 필요. 스택에 상태 저장.
- 각 스레드는 CPU 레지스터를 완전히 소유한다고 간정
- 스레드 스케쥴러가 CPU 레지스터 저장


## 락

- 여러 작은 연산으로 이뤄진 작업을 어떻게 원자적(나눌 수 없고 인터럽트할 수 없음)으로 만들 수 있을까?
- 상호배제 메커니즘 사용
  - 락/뮤텍스: 명시적 동기화
  - 트랜잭션: 모두 성공 or 모두 실패
  - 원자적 명령어: Test-and-Set, Compare-and-Swap (CAS)

### 트랜잭션과 작업 크기

- 읽기 → 계산 → 쓰기 가 하나의 트랜잭션처럼 작동해야 함
- 락이 걸린 작업의 크기(granularity)를 최소화(fine-grained)하는 것이 좋다
- 좋은 락 설계는 짧고, 작고, 국소적으로

### 락 대기

- 프로그램이 락 대기 동안 아무것도 못함
- 락을 관리하는 쪽에 등록하고, 요청이 받아들여졌을 때 통지 받기
- 블로킹: 시스템이 락을 할당할 수 있을 때까지 요청한 프로그램을 일시 중단(suspend)함
- 논블로킹: 프로그램이 계속 실행되고 나중에 락을 얻었는지 여부를 어떤 방식으로든 통지받게 됨

### 교착 상태(Deadlock)

- 두 스레드/프로세스가 서로의 자원을 기다리며 무한 대기하는 상태
- 교착상태 발생 조건
  - 상호배제 : 공유 자원을 함께 쓸 수 없어서 어느 한 프로세스가 독점적으로 사용할 때
  - 점유대기 : 프로세스들은 어느 자원을 점유한 상태에서 다른 자원을 요청할 때
  - 비선점 : 프로세스가 할당받은 자원을 강제로 빼앗을 수 없을 때
  - 순환대기 : 각 프로세스가 서로 순환적으로 다른 프로세스가 갖고 있는 자원을 요구할 때
- 교착상태 해법
  - 자원을 상호 배제하지 않고 언제든 공유할 수 있는 자원으로 만든다.
  - 어느 자원을 점유한 다음에 다른 자원을 요구하지 않고 한꺼번에 자원을 요구한다.
  - 선점형(자원을 강제로 회수하거나 프로세스의 실행을 중단하고 다른 프로세스에 자원을 할당하는 방식) 으로 바꾼다.
  - 자원마다 우선순위를 부여해서 모든 프로세스가 다 서로 정해진 순서대로만 자원을 요구한다.


## 브라우저 자바스크립트

- JS는 싱글 스레드 기반
- 동시성은 **이벤트 루프(Event Loop)**로 처리
- 백그라운드에서 Web API가 작업을 수행한 후 콜백 큐에 등록
- 콜백 큐 vs 마이크로태스크 큐(Promise 등 우선순위 높음)
- 콜백 지옥 → Promise → async/await 로 진화

> [!NOTE]
> JS 의 Web Worker를 통한 병렬 처리?
