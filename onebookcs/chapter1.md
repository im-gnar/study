## 1장: 컴퓨터 내부의 언어 체계

### 비트와 비트의 의미 부여

- 비트는 2진법을 사용 (0과 1)
- n비트로는 2ⁿ 개의 상태 표현 가능
- 논리 연산 : 다른 비트의 표현으로부터 새로운 비트를 만들어내는 동작


드모르간의 법칙
a XOR b => (a OR b) AND (NOT(a AND b))
연산은 돈이 들기 때문

### 정수와 실수의 표현

- 정수는 2진수로 표현
  - 4비트는 0~15, 32비트는 0 ~ 4,294,967,295 (= unsigned int 범위)
- 양수와 음수를 구분하기 위해 MSB를 비트로 사용
  - 때문에 n 비트는 2^n-1 까지 음/양의 정수 표현 가능
  - 32비트인 int 는 -2,147,483,648 ~ 2,147,483,647 (-2³¹ ~ 2³¹ - 1)
  - 음수가 양수보다 1 큰 이유는 0 때문

> unsigned : 양수 음수 구분 없이 숫자표현만
> signed : 맨 앞 비트(MSB)를 양수 음수 플래그로 사용
> unsigned로 큰 값 쓰다가 signed로 바꿔버리면 뜬금없이 음수가 나옴

| 정수| MSB |  | | LSB |
|:--:|:--:|:--:|:--:|:--:|
|+5 |0|1|0|1|
|-5 |1|1|0|1|

비트 하나를 부호 역할로 사용하고 나머지 비트로 수를 표현하는 방법을 부호와 크기(Sign and Magnitude) 표현법이라고 한다.

But 아래와 같은 이유로 사용되지 않음
- 0을 표현하는 방법이 +0과 -0으로 두 가지라서 비용이 낭비된다.
- AND와 XOR을 사용한 덧셈 계산 불가(논리 연산자를 이용한 세로 나열 방식)


1의 보수

양수의 모든 비트를 1에서 0, 0에서 1로 모두 뒤집어 표현하는 1의 보수(one's complement) 표현법

| 정수| MSB |  | | LSB |
|:--:|:--:|:--:|:--:|:--:|
|+7 |0|1|1|1|
|-7 |1|0|0|0|


동일하게 0을 두 가지로 표현한다는 문제가 존재하며, MSB에서 올림이 발생한 경우 다시 LSB로 전달하는 순환 올림(End-around carry)을 해야 한다.



- 실수는 고정소수점이나 부동소수점 방식으로 표현
- IEEE 부동소수점 표준

### 문자 언어와 비트

문자 언어는 기호의 집합으로 구성되며, 컴퓨터에서는 이러한 기호를 비트로 변환하여 처리

예를 들어, ASCII 코드나 유니코드를 통해 문자를 비트로 표현


### 진법과 코드화

2진수, 8진수, 16진수 등

프로그래밍 언어에서는 이러한 진법을 사용하여 숫자를 코드화


---


- 비트 연산자(&, |, ^, !)와 논리 연산자
- 비트마스킹, 암호화 등 활용 사례