# Chapter8. 경계

### 외부 코드 사용하기

- `패키지/프레임워크 제공자` : 더 많은 환경에서 코드가 돌아가도록 적용성을 최대한 넓히려 애쓴다.
- `패키지/프레임워크 사용자` : 자신의 요구에 집중하는 인터페이스를 원한다.

#### Map

Map이 제공하는 기능성과 유연성은 유용하지만 그만큼 위험도 크다.


- 필요하지 않은 기능 또한 제공 (EX. `clear()` 함수)
  - 클라이언트가 언제든지 해당 메서드로 Map 값을 지울 수 있다.

```java
// Bad
Map sensors = new HashMap();
Sensor s = (Sensor) sensors.get(sensorId);
```
- Map 이 반환하는 Object를 올바른 유형으로 변환할 책임이 클라이언트에게 넘겨진다.
  - 변환 코드를 작성하는 사람이 사용자이므로 코드 간의 불일치성을 초래할 수 있다.
  - 또한 함수와 인자 사이에 어떤 관계가 있는지 함수 이름을 보고도 알기가 힘들다.
  - 의도가 분명히 드러나지 않기 때문에 깨끗한 코드라 부르기 어렵다.


```java
Map<String, Sensor> sensors = new HashMap<Sensor>();
Sensor s = sensors.get(sensorId);
```

- 제네릭을 사용해 코드 가독성을 높였다
  - 그러나 Map<String, Sensor> 은 여전히 사용자에게 필요하지 않은 기능까지 제공하고있다.(`clear()...`)
- Map 인스턴스 사용 중에 인터페이스가 변할 경우, 수정할 코드가 많아진다.
  - 실제로 자바5 에서 제네릭을 도입했을 때 Map 인터페이스가 변한적 있다.
  - 이로 인해 제네릭 사용을 금하는 시스템도 있다.

```java
public class Sensors {
    private Map sensors = new HashMap();
    
    public Sensor getById(String id) {
        return (sensor) sensors.get(id);
    }
}
```

경계 인터페이스인 Map을 Wrapper(Sensor) 클래스 안으로 숨겼다.
- 사용자는 Map에 제네릭스가 사용되었는지 여부에 신경 쓸 필요가 없어졌다.
- Map 인터페이스가 변하더라도 Wrapper 객체를 사용하기에 다른 프로그램에는 영향을 미치지 않는다.
- 프로그램에 필요한 인터페이스만 제공할 수 있다.
- 필요한 인터페이스를 사용하는 과정에서 보다 명확한 이름을 지정해줄 수 있다.
- Wrapper 클래스는 설계 규칙과 비즈니스 규칙을 따르도록 강제할 수 있다.

하지만, Map 클래스를 사용할 때마다 캡슐화하라는 소리는 아니다.
- Map과 같은 경계 인터페이스를 여기저기 넘기지 말라는 말이다.
- Map과 같은 경계 인터페이스를 사용할때는 클래스나 클래스 계열 밖으로 노출되지 않도록 주의해야한다.
- Map 인스턴스를 공개 API의 인수로 넘기거나 반환값으로 사용하지 말자.


### 경계 살피고 익히기

외부 패키지에 대한 테스트는 우리의 책임은 아니다.<BR>
하지만 우리 자신을 위해 우리가 사용할 외부 코드를 미리 테스트하는 편은 바람직하다.<BR>
타사 라이브러리를 코드에 적용시켜 동작을 확인했는데 버그가 발생하면 우리 코드 문제인지 라이브러리 문제인지 오래 디버깅을 해야한다.

#### 학습 테스트

- 외부 코드를 익히거나 통합하기란 어렵다.
- 우리쪽 코드를 작성해 외부 코드를 호출하는 대신 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익히는 방법은 어떨까?
- 학습 테스트는 API를 사용하려는 목적에 초점을 맞추고 우리 프로그램에서 사용하려는 방식대로 API를 호출하여 이해하는 방식이다.

#### 학습 테스트는 공짜 이상이다 

- 외부 패키지에 대한 이해도를 높여준다.
- 외부 패키지가 예상대로 도는지 검증한다.
- 외부 패키지의 새 버전으로 이전하기 쉬워진다.
- 외부 패키지의 새 버전이 나온다면 학습 테스트를 돌려 호환성을 확인할 수 있다.

#### 아직 존재하지 않는 코드를 사용하기

```
지정한 주파수를 이용해 이 스트림에서 들어오는 자료를 아날로그 신호로 전송하라.
```

협업하는 팀에서 아직 API를 설계하지 않아서 구체적인 구현 방법을 모른다.<BR>
그래서 우리 팀은 구현을 나중으로 미루고 이쪽 코드를 진행하고자 자체적으로 인터페이스를 정의했다.


![image](https://github.com/rachel5004/study/assets/75432228/461c7d25-68c6-4abb-967a-8b55f76362ff)

`Transmitter`라는 간단한 클래스를 만들고 `transmit` 라는 메서드를 추가했다.<BR>
협업하는 팀에서 API를 정의한 후에는 `TransmitterAdapter`를 구현해 간극을 메웠다.<BR>
ADAPTER 패턴으로 API 사용을 캡슐화해 API가 바뀔 때 수정할 코드를 한곳으로 모았다.

- 우리가 인터페이스를 전적으로 통제한다는 장점이 있다.
- 코드의 가독성이 높아지고 코드 의도도 분명해진다.
- 테스트도 아주 편리하게 할 수 있다. (경계 테스트 활용 가능)


### 깨끗한 경계

- 경계에 위치하는 코드는 깔끔히 분리한다
- 기대치(목표)를 정의하는 테스트 케이스도 작성한다
- 통제가 불가능한 외부 패키지에 의존하는 대신 통제가 가능한 우리 코드에 의존하자
- 외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리하자
- 새로운 클래스로 경계를 감싸거나 ADAPTER 패턴을 사용해 원하는 인터페이스를 패키지가 제공하는 인터페이스로 변환하자
